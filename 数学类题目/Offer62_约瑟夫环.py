'''
剑指 Offer 62. 圆圈中最后剩下的数字
0,1,,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字。求出这个圆圈里剩下的最后一个数字。

例如，0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。

示例 1：

输入: n = 5, m = 3
输出: 3
示例 2：

输入: n = 10, m = 17
输出: 2
'''
class Solution:
    def lastRemaining(self, n: int, m: int) -> int:
        # https://blog.csdn.net/u011500062/article/details/72855826
        '''
        可以看做n到n-1个数时，是减去的那个数后面的数字全部往左移动了m个位置，因为他们从（m，m+1,..)变成了(0,1,...)
        所以逆过程就是 n-1到n时，是n-1个数时每个数字的位置全部往右移动m个位置，就变成了n个数时的序号，也就是(0,1,...)变成了（m，m+1,..)
        也就是f(n) = (f(n-1) + m)%n 因为+m可能回超过n，所以就取余
        说明：f(n)表示n个数时，最终的答案所在的序号，例子中式2，f(n-1)表示n-1个数时，最终的答案所在的序号，例子中是2
        之所以逆过程 是因为可以确定f(1)时一定是0，因为就一个数字了，停止了
        '''

        # 数学公式递推
        if n < 1 or m < 1:
            return None
        # f(n) = (f(n-1) + m)%n
        # 已知n-1个人时，最终答案在n-1的序列中的下标，那么n个人时，相当于该位置都加m，然后可能在n的序列中溢出，所以对n取模
        # n=1时，只有一个数，下标肯定是0
        last = 0
        for i in range(2, n+1):
            last = (last + m)%i
        return last